<html>
  <head>
    <!-- SPDX-License-Identifier: GPL-3.0-only -->
    <title>6502 / 6510 / 8502 Opcode List</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="SPDX-License-Identifier" content="GPL-3.0-only">

    <style type="text/css">
      body {
          background-image: linear-gradient(#fed, #765);
          font-family: sans-serif;
      }

      body > h1 {
          width: 100%;
          display: block;
          text-align: center;
          text-shadow: 2px 2px #888;
          color: #000;
      }

      categories {
          display: flex;
          columns: 300px;
          -webkit-columns: 300px;
          -moz-columns: 300px;
          flex-direction: column;
          flex-wrap: wrap;
          align-content: flex-start;
          justify-content: flex-start;
          background: #fff;
          border: 1px solid #000;
          padding: 1em;
          margin: 0px auto 0px auto;
          width: 300px;
      }

      categories table th { color: white; }
      categories table:nth-child(1) th  { background-color: #800; }
      categories table:nth-child(2) th  { background-color: #e00; }
      categories table:nth-child(3) th  { background-color: #e80; }
      categories table:nth-child(4) th  { background-color: #da0; }
      categories table:nth-child(5) th  { background-color: #4a4; }
      categories table:nth-child(6) th  { background-color: #2aa; }
      categories table:nth-child(7) th  { background-color: #06c; }
      categories table:nth-child(8) th  { background-color: #47c; }
      categories table:nth-child(9) th  { background-color: #82c; }
      categories table:nth-child(10) th { background-color: #a2c; }
      categories table:nth-child(11) th { background-color: #c2c; }

      categories table:nth-child(1) td  { background-color: #e99; }
      categories table:nth-child(2) td  { background-color: #f88; }
      categories table:nth-child(3) td  { background-color: #fb6; }
      categories table:nth-child(4) td  { background-color: #fc2; }
      categories table:nth-child(5) td  { background-color: #ada; }
      categories table:nth-child(6) td  { background-color: #aee; }
      categories table:nth-child(7) td  { background-color: #6ae; }
      categories table:nth-child(8) td  { background-color: #8af; }
      categories table:nth-child(9) td  { background-color: #cbf; }
      categories table:nth-child(10) td { background-color: #ebe; }
      categories table:nth-child(11) td { background-color: #fce; }

      table th  { background-color: #4a4; }
      table td  { background-color: #ada; }

      table {
          width: 300px;
          margin: 3px;
          padding: 0px;
          background-color: #000;
      }

      table td {
          text-align: center;
          margin: 0px;
          padding: 5px;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
          cursor: pointer;
      }

      table td a {
          display: block;
          width: 100%;
          height: 100%;
          color: black;
      }

      table th {
          margin: 0px;
          padding: 5px;
          text-shadow: 1px 1px #333;
      }

      table tr {
          margin: 0px;
          padding: 0px;
      }

      footer {
          display: block;
          margin: 0px auto 0px auto;
          padding-top: 10px;
          text-align: center;
          width: 100%;
          bottom: 5px;
          color: #fff;
          font-size: small;
      }

      footer a {
          color: #fff;
          text-shadow: 1px 1px #333;
      }

      description {
          display: none;
          position: fixed;
          width: 100%;
          height: 100%;
          top: 0%;
          left: 0%;
          border: 1px solid #000;
          background: #fff;
          box-shadow: 0 4px 8px 0 #333;
          overflow: scroll;
          overscroll-behavior: contain;
          -ms-scroll-chaining: none;
      }

      description closebutton {
          display: block;
          float: right;
          margin: 10px;
          padding: 8px;
          color: #fff;
          border: 1px solid #f00;
          background-color: #f00;
          background-image: linear-gradient(#f00, #faa);
          text-shadow: 2px 2px #000;
          cursor: pointer;
          font-weight: 900;
      }

      description heading {
          display: block;
          padding: 10px;
          font-size: 2em;
          font-weight: bold;
          background-image: linear-gradient(#dfd, #0a0);
          text-shadow: 2px 2px #fff;
      }

      description subtext {
          display: block;
          padding: 10px;
          font-size: 1.5em;
          font-weight: bold;
          margin-bottom: 10px;
          margin-left: 0px;
      }

      description flags {
          display: block;
          padding: 0px 0px 10px 10px;
      }

      description operation {
          display: block;
          padding: 0px 0px 10px 10px;
      }

      description bits {
          display: inline-block;
          padding: 2px;
          border: 1px solid #000;
          font-family: monospace;
          letter-spacing: 5px;
      }

      description table {
          width: 100%;
          margin: 0px;
          padding: 0px;
          background-color: #fff;
      }

      description tr td {
          text-align: left;
      }

      description table tr td:nth-child(2),
      description table tr td:nth-child(3) {
          font-family: monospace;
          font-weight: bold;
      }

      description ol li {
          font-size: small;
      }

      description text {
          display: block;
          overflow: scroll;
          padding: 10px;
          white-space: normal;
      }

      description pre {
          margin: 1em 0em 0em 4em;
          padding: 0px;
      }

      description p {
          margin: 2px 2px 4px 2px;
          padding: 2px;
      }
    </style>

    <script>
      opcodes = {
          "ADC": {
              "mnemonic": "ADd with Carry",
              "operation": "A + operand + carry &rarr; A, C",
              "flags": [ "N", "V", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "ADC #$44",    "$69", 2, 2 ],
                  [ "Zero Page",    "ADC $44",     "$65", 2, 3 ],
                  [ "Zero Page, X", "ADC $44,X",   "$75", 2, 4 ],
                  [ "Absolute",     "ADC $4400",   "$6D", 3, 4 ],
                  [ "Absolute, X",  "ADC $4400,X", "$7D", 3, 4, 1 ],
                  [ "Absolute, Y",  "ADC $4400,Y", "$79", 3, 4, 1 ],
                  [ "Indirect, X",  "ADC ($44,X)", "$61", 2, 6 ],
                  [ "Indirect, Y",  "ADC ($44),Y", "$71", 2, 5, 1 ],
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ],
              "description": "<p>ADC adds the operand and carry bit, and stores\
                  the result in A.<p>ADC results are dependant on the setting of the\
                  decimal flag. In decimal mode, addition is carried out on the\
                  assumption that the values are packed BCD (Binary Coded Decimal).\
                  <p>There is no way to add without carry.",
          },
          "AND": {
              "mnemonic": "bitwise AND with accumulator",
              "operation": "A AND mem &rarr; A",
              "flags": [ "N", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "AND #$44",    "$29", 2, 2 ],
                  [ "Zero Page",    "AND $44",     "$25", 2, 3 ],
                  [ "Zero Page, X", "AND $44,X",   "$35", 2, 4 ],
                  [ "Absolute",     "AND $4400",   "$2D", 3, 4 ],
                  [ "Absolute, X",  "AND $4400,X", "$3D", 3, 4, 1 ],
                  [ "Absolute, Y",  "AND $4400,Y", "$39", 3, 4, 1 ],
                  [ "Indirect, X",  "AND ($44,X)", "$21", 2, 6 ],
                  [ "Indirect, Y",  "AND ($44),Y", "$31", 2, 5, 1 ],
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ],
              "description": "<p>AND performs a bitwise AND with the accumulator\
                  and stores the result in the accumulator.",
          },
          "ASL": {
              "mnemonic": "Arithmetic Shift Left",
              "operation": "C &larr; <bits>7654321</bits> &larr; 0",
              "flags": [ "N", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Accumulator",  "ASL",         "$0A", 1, 2 ],
                  [ "Zero Page",    "ASL $44",     "$06", 2, 5 ],
                  [ "Zero Page, X", "ASL $44,X",   "$16", 2, 6 ],
                  [ "Absolute",     "ASL $4400",   "$0E", 3, 6 ],
                  [ "Absolute, X",  "ASL $4400,X", "$1E", 3, 7 ],
              ],
              "description": "<p>ASL shifts all bits left one position. 0 is\
                  shifted into bit 0 and the original bit 7 is shifted into the\
                  Carry flag."
          },
          "BIT": {
              "mnemonic": "test BITs",
              "operation": "A AND mem,<br>\
                            mem<sub>7</sub> &rarr; N,<br>\
                            mem<sub>6</sub> &rarr; V",
              "flags": [ "N", "V", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Zero Page",    "BIT $44",     "$24", 2, 3 ],
                  [ "Absolute",     "BIT $4400",   "$2C", 3, 4 ],
              ],
              "description": "<p>BIT sets the Z flag as though the value in the\
                  address tested were ANDed with the accumulator. The N and V\
                  flags are set to match bits 7 and 6 respectively in the value\
                  stored at the tested address.\
                  <p>BIT is often used to skip one or two following bytes as in:\
                  <pre>\
CLOSE1 LDX #$10       If entered here, we\n\
       .BYTE $2C      effectively perform\n\
CLOSE2 LDX #$20       a BIT test on $20A2,\n\
       .BYTE $2C      another one on $30A2,\n\
CLOSE3 LDX #$30       and end up with the X\n\
CLOSEX LDA #12        register still at $10\n\
       STA ICCOM,X    upon arrival here.\n\
                  </pre>\
                  <p>Beware: a BIT instruction used in this way as a NOP does have\
                  effects: the flags may be modified, and the read of the\
                  absolute address, if it happens to access an I/O device, may\
                  cause an unwanted action."
          },

          "BPL": {
              "mnemonic": "Branch on PLus",
              "operation": "Branch to offset when N = 0",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BPL $4400",   "$10", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  \
                  <p>There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  \
                  <p>A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  <p>A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BMI": {
              "mnemonic": "Branch on MInus",
              "operation": "Branch to offset when N = 1",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BMI $4400",   "$30", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  <p>A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BVC": {
              "mnemonic": "Branch on oVerflow Clear",
              "flags": [ ],
              "operation": "Branch to offset when V = 0",
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BVC $4400",   "$50", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  <p>A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\n\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BVS": {
              "mnemonic": "Branch on oVerflow Set",
              "operation": "Branch to offset when V = 1",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BVS $4400",   "$70", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\n\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BCC": {
              "mnemonic": "Branch on Carry Clear",
              "operation": "Branch to offset when C = 0",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BCC $4400",   "$90", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  <p>A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BCS": {
              "mnemonic": "Branch on Carry Set",
              "operation": "Branch to offset when C = 1",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BCS $4400",   "$B0", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  <p>A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
<pre>\n\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BNE": {
              "mnemonic": "Branch on Not Equal",
              "flags": [ ],
              "operation": "Branch to offset when Z = 0",
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BPL $4400",   "$D0", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\n\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },
          "BEQ": {
              "mnemonic": "Branch on EQual",
              "operation": "Branch to offset when Z = 1",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Relative",     "BEQ $4400",   "$F0", 2, 3, 1 ],
              ],
              "notes": [
                  "A branch not taken requires two machine cycles. If the branch\
                   is taken, add another cycle if it crosses a page boundary."
              ],
              "description": "<p>All branches are relative mode and have a length\
                  of two bytes. Branches are dependant on the status of the flag\
                  bits when the op code is encountered.\
                  <p>\
                  There is no BRA (BRanch Always) instruction, but it can be\
                  easily emulated by branching on the basis of a known\
                  condition. One of the best flags to use for this purpose is\
                  oVerflow which is unchanged by all but addition and\
                  subtraction operations.\
                  <p>\
                  A page boundary crossing occurs when the branch destination is\
                  on a different page than the instruction AFTER the branch\
                  instruction. For example:\
                  <pre>\n\
SEC\n\
BCS LABEL\n\
NOP\n\
                  </pre>\
                  A page boundary crossing occurs (i.e. the BCS takes 4 cycles)\
                  when (the address of) LABEL and the NOP are on different\
                  pages. This means that\
                  <pre>\n\
      CLV\n\
      BVC LABEL\n\
LABEL NOP\n\
                  </pre>\
                  <p>the BVC instruction will take 3 cycles no matter what address\
                  it is located at."
          },

          "BRK": {
              "mnemonic": "BReaK to non-maskable interrupt handler",
              "operation": "Forced interrupt, PC + 2 pushed, SP pushed",
              "flags": [ "B" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "BRK",         "$00", 1, 7 ],
              ],
              "description": "<p>BRK causes a non-maskable interrupt and increments\
                  the program counter by one. Therefore an RTI will go to the\
                  address of the BRK +2 so that BRK may be used to replace a\
                  two-byte instruction for debugging and the subsequent RTI will\
                  be correct."
          },

          "CMP": {
              "mnemonic": "CoMPare accumulator",
              "operation": "A - mem",
              "flags": [ "N", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "CMP #$44",    "$C9", 2, 2 ],
                  [ "Zero Page",    "CMP $44",     "$C5", 2, 3 ],
                  [ "Zero Page, X", "CMP $44,X",   "$D5", 2, 4 ],
                  [ "Absolute",     "CMP $4400",   "$CD", 3, 4 ],
                  [ "Absolute, X",  "CMP $4400,X", "$DD", 3, 4, 1 ],
                  [ "Absolute, Y",  "CMP $4400,Y", "$D9", 3, 4, 1 ],
                  [ "Indirect, X",  "CMP ($44,X)", "$C1", 2, 6 ],
                  [ "Indirect, Y",  "CMP ($44),Y", "$D1", 2, 5, 1 ]
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ],
              "description": "<p>Compare sets flags as if a subtraction had been\
                  carried out. If the value in the accumulator is equal or\
                  greater than the compared value, the Carry flag will be set.\
                  The equal (Z) and sign (S) flags will be set based on equality\
                  or lack thereof and the sign (i.e. A>=$80) of the\
                  accumulator."
          },
          "CPX": {
              "mnemonic": "CoMPare X register",
              "operation": "X - mem",
              "flags": [ "N", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "CPX #$44",    "$E0", 2, 2 ],
                  [ "Zero Page",    "CPX $44",     "$E4", 2, 3 ],
                  [ "Absolute",     "CPX $4400",   "$EC", 3, 4 ],
              ],
              "description": "<p>Compare sets flags as if a subtraction had been\
                  carried out. If the value in the accumulator is equal or\
                  greater than the compared value, the Carry flag will be set.\
                  The equal (Z) and sign (S) flags will be set based on equality\
                  or lack thereof and the sign (i.e. A>=$80) of the\
                  accumulator."
          },
          "CPY": {
              "mnemonic": "CoMPare Y register",
              "operation": "Y - mem",
              "flags": [ "N", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "CPX #$44",    "$C0", 2, 2 ],
                  [ "Zero Page",    "CPX $44",     "$C4", 2, 3 ],
                  [ "Absolute",     "CPX $4400",   "$CC", 3, 4 ],
              ],
              "description": "<p>Compare sets flags as if a subtraction had been\
                  carried out. If the value in the accumulator is equal or\
                  greater than the compared value, the Carry flag will be set.\
                  The equal (Z) and sign (S) flags will be set based on equality\
                  or lack thereof and the sign (i.e. A>=$80) of the\
                  accumulator."
          },

          "DEC": {
              "mnemonic": "DECrement memory",
              "operation": "mem - 1 &rarr; mem",
              "flags": [ "N", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Zero Page",    "DEC $44",     "$C6", 2, 5 ],
                  [ "Zero Page, X", "DEC $44,X",   "$D6", 2, 6 ],
                  [ "Absolute",     "DEC $4400",   "$CE", 3, 6 ],
                  [ "Absolute, X",  "DEC $4400,X", "$DE", 3, 7 ],
              ],
          },
          "EOR": {
              "mnemonic": "bitwise Exclusive OR",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "EOR #$44",    "$49", 2, 2 ],
                  [ "Zero Page",    "EOR $44",     "$45", 2, 3 ],
                  [ "Zero Page, X", "EOR $44,X",   "$55", 2, 4 ],
                  [ "Absolute",     "EOR $4400",   "$4D", 3, 4 ],
                  [ "Absolute, X",  "EOR $4400,X", "$5D", 3, 4, 1 ],
                  [ "Absolute, Y",  "EOR $4400,Y", "$59", 3, 4, 1 ],
                  [ "Indirect, X",  "EOR ($44,X)", "$41", 2, 6 ],
                  [ "Indirect, Y",  "EOR ($44),Y", "$51", 2, 5, 1 ]
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ],
          },

          "CLC": {
              "mnemonic": "CLear Carry",
              "flags": [ "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "CLC",         "$18", 1, 2 ],
              ],
          },
          "SEC": {
              "mnemonic": "SEt Carry",
              "flags": [ "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "SEC",         "$38", 1, 2 ],
              ],
          },
          "CLI": {
              "mnemonic": "CLear Interrupt",
              "flags": [ "I" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "CLI",         "$58", 1, 2 ],
              ],
              "description": "<p>The Interrupt flag is used to prevent (SEI) or\
              enable (CLI) maskable interrupts (aka IRQ's). It does not signal\
              the presence or absence of an interrupt condition. The 6502 will\
              set this flag automatically in response to an interrupt and\
              restore it to its prior status on completion of the interrupt\
              service routine. If you want your interrupt service routine to\
              permit other maskable interrupts, you must clear the I flag in\
              your code."
          },
          "SEI": {
              "mnemonic": "SEt Interrupt",
              "flags": [ "I" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "SEI",         "$78", 1, 2 ],
              ],
              "description": "<p>The Interrupt flag is used to prevent (SEI) or\
              enable (CLI) maskable interrupts (aka IRQ's). It does not signal\
              the presence or absence of an interrupt condition. The 6502 will\
              set this flag automatically in response to an interrupt and\
              restore it to its prior status on completion of the interrupt\
              service routine. If you want your interrupt service routine to\
              permit other maskable interrupts, you must clear the I flag in\
              your code."
          },
          "CLV": {
              "mnemonic": "CLear oVerflow",
              "flags": [ "V" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "CLV",         "$B8", 1, 2 ],
              ],
              "description": "<p>The overflow flag is generally misunderstood and\
              therefore under-utilized. After an ADC or SBC instruction, the\
              overflow flag will be set if the twos compliment result is less\
              than -128 or greater than +127, and it will be cleared otehrwise.\
              In twos compliment, $80 through $FF represents -128 through -1,\
              and $00 through $7F represents 0 through +127. Thus, after:\
              <pre>\n\
CLC\n\
LDA #$7F ;    +127\n\
ADC #$01 ; +    +1\n\
              </pre>\
              <p>the overflow flag is 1 (+127 + + 1 = +128), and after:\
              <pre>\n\
CLC\n\
LDA #$81 ;    -127\n\
ADC #$FF ; +    -1\n\
              </pre>\
              <p>the overflow flag is 0 (-127 + -1 = -128). The overflow flag is\
          not affected by increments, decrements, shifts and logical operations\
          i.e. only ADC, BIT, CLV, PLP, RTI, and SBC affect it. There is no op\
          code to set the overflow, but a BIT test on an RTS instruction will do\
          the trick."
          },
          "CLD": {
              "mnemonic": "CLear Decimal",
              "flags": [ "D" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "CLD",         "$D8", 1, 2 ],
              ],
              "description": "<p>The Decimal flag controls how the 6502 adds and\
          subtracts. If set, arithmetic is carried out in packed binary coded\
          decimal. This flag is unchanged by interrupts and is unknown on\
          power-up. The implication is that a CLD should be included in boot or\
          interrupt coding."
          },
          "SED": {
              "mnemonic": "SEt Decimal",
              "flags": [ "D" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "SED",         "$F8", 1, 2 ],
              ],
              "description": "<p>The Decimal flag controls how the 6502 adds and\
          subtracts. If set, arithmetic is carried out in packed binary coded\
          decimal. This flag is unchanged by interrupts and is unknown on\
          power-up. The implication is that a CLD should be included in boot or\
          interrupt coding."
          },

          "INC": {
              "mnemonic": "INCrement memory",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Zero Page",    "INC $44",     "$E6", 2, 5 ],
                  [ "Zero Page, X", "INC $44,X",   "$F6", 2, 6 ],
                  [ "Absolute",     "INC $4400",   "$EE", 3, 4 ],
                  [ "Absolute, X",  "INC $4400,X", "$FE", 3, 7 ],
              ],
          },

          "JMP": {
              "mnemonic": "JuMP",
              "flags": [ ],
              "modes": [
                  [ "Absolute",     "JMP $5597",   "$4C", 3, 3 ],
                  [ "Indirect",     "JMP ($5597)", "$6C", 3, 5 ],
              ],
              "description": "<p>JMP transfers program execution to the following\
              address (absolute) or to the location contained in the following\
              address (indirect). Note that there is no carry associated with\
              the indirect jump, so:\
              <p style=\"color:red;\">\
              AN INDIRECT JUMP MUST NEVER USE A VECTOR BEGINNING ON THE LAST\
              BYTE OF A PAGE\
              <p>\
              For example if address $3000 contains $40, $30FF contains $80, and\
          $3100 contains $50, the result of JMP ($30FF) will be  atransfer of\
          control to $4080 rather than $5080 as you inteded i.e. the 6502 took\
          the low byte of the address from $30FF and the high byte from $3000."
          },
          "JSR": {
              "mnemonic": "Jump to SubRoutine",
              "flags": [ ],
              "modes": [
                  [ "Absolute",     "JSR $5597",   "$20", 3, 6 ],
              ],
              "description": "<p>JSR pushes the address-1 of the next operation on\
          to the stack before transferring program control to the following\
          address. Subroutines are normally terminated by an RTS opcode."
          },

          "LDA": {
              "mnemonic": "LoaD Accumulator",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "LDA #$44",    "$A9", 2, 2 ],
                  [ "Zero Page",    "LDA $44",     "$A5", 2, 3 ],
                  [ "Zero Page, X", "LDA $44,X",   "$B5", 2, 4 ],
                  [ "Absolute",     "LDA $4400",   "$AD", 3, 4 ],
                  [ "Absolute, X",  "LDA $4400,X", "$BD", 3, 4, 1 ],
                  [ "Absolute, Y",  "LDA $4400,Y", "$B9", 3, 4, 1 ],
                  [ "Indirect, X",  "LDA ($44,X)", "$A1", 2, 6 ],
                  [ "Indirect, Y",  "LDA ($44),Y", "$B1", 2, 5, 1 ]
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ]
          },
          "LDX": {
              "mnemonic": "LoaD X register",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "LDX #$44",    "$A2", 2, 2 ],
                  [ "Zero Page",    "LDX $44",     "$A6", 2, 3 ],
                  [ "Zero Page, Y", "LDX $44,X",   "$B6", 2, 4 ],
                  [ "Absolute",     "LDX $4400",   "$AE", 3, 4 ],
                  [ "Absolute, Y",  "LDX $4400,Y", "$BE", 3, 4, 1 ],
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ]
          },
          "LDY": {
              "mnemonic": "LoaD Y register",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "LDY #$44",    "$A0", 2, 2 ],
                  [ "Zero Page",    "LDY $44",     "$A4", 2, 3 ],
                  [ "Zero Page, X", "LDY $44,X",   "$B4", 2, 4 ],
                  [ "Absolute",     "LDY $4400",   "$AC", 3, 4 ],
                  [ "Absolute, X",  "LDY $4400,Y", "$BC", 3, 4, 1 ],
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ]
          },

          "LSR": {
              "mnemonic": "Logical Shift Right",
              "flags": [ "S", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Accumulator",  "LSR A",       "$4A", 1, 2 ],
                  [ "Zero Page",    "LSR $44",     "$46", 2, 5 ],
                  [ "Zero Page, X", "LSR $44,X",   "$56", 2, 6 ],
                  [ "Absolute",     "LSR $4400",   "$4E", 3, 6 ],
                  [ "Absolute, X",  "LSR $4400,X", "$5E", 3, 7 ],
              ],
              "description": "<p>LSR shifts all bits right one position. Bit 0\
              is shifted into bit 7 and the original bit 0 is shifted into the\
              Carry."
          },

          "NOP": {
              "mnemonic": "No OPeration",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "NOP",         "$EA", 1, 2 ],
              ],
              "description": "<p>NOP is used to reserve space for future\
              modifications or effectively REM out existing code."
          },

          "ORA": {
              "mnemonic": "bitwise OR with Accumulator",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "ORA #$44",    "$09", 2, 2 ],
                  [ "Zero Page",    "ORA $44",     "$05", 2, 3 ],
                  [ "Zero Page, X", "ORA $44,X",   "$15", 2, 4 ],
                  [ "Absolute",     "ORA $4400",   "$0D", 3, 4 ],
                  [ "Absolute, X",  "ORA $4400,X", "$1D", 3, 4, 1 ],
                  [ "Absolute, Y",  "ORA $4400,Y", "$19", 3, 4, 1 ],
                  [ "Indirect, X",  "ORA ($44,X)", "$01", 2, 6 ],
                  [ "Indirect, Y",  "ORA ($44),Y", "$11", 2, 5, 1 ]
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ]
          },

          "TAX": {
              "mnemonic": "Transfer A to X",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "TAX",         "$AA", 1, 2 ],
              ],
          },
          "TXA": {
              "mnemonic": "Transfer X to A",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "TXA",         "$8A", 1, 2 ],
              ],
          },
          "DEX": {
              "mnemonic": "DEcrement X",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "DEX",         "$CA", 1, 2 ],
              ],
          },
          "INX": {
              "mnemonic": "INcrement X",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "INX",         "$E8", 1, 2 ],
              ],
          },
          "TAY": {
              "mnemonic": "Transfer A to Y",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "TAY",         "$A8", 1, 2 ],
              ],
          },
          "TYA": {
              "mnemonic": "Transfer Y to A",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "TYA",         "$98", 1, 2 ],
              ],
          },
          "DEY": {
              "mnemonic": "DEcrement Y",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "DEY",         "$88", 1, 2 ],
              ],
          },
          "INY": {
              "mnemonic": "INcrement Y",
              "flags": [ "S", "Z" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "INY",         "$C8", 1, 2 ],
              ],
          },

          "ROL": {
              "mnemonic": "ROtate Left",
              "flags": [ "S", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Accumulator",  "ROL A",       "$2A", 1, 2 ],
                  [ "Zero Page",    "ROL $44",     "$26", 2, 5 ],
                  [ "Zero Page, X", "ROL $44,X",   "$36", 2, 6 ],
                  [ "Absolute",     "ROL $4400",   "$2E", 3, 6 ],
                  [ "Absolute, X",  "ROL $4400,X", "$3E", 3, 7 ],
              ],
              "description": "<p>ROL shifts all bits left one position. The\
              Carry flag is shifted into bit 0 and the original bit 7 is shifted\
              into the Carry flag."
          },
          "ROR": {
              "mnemonic": "ROtate Right",
              "flags": [ "S", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Accumulator",  "ROL A",       "$6A", 1, 2 ],
                  [ "Zero Page",    "ROL $44",     "$66", 2, 5 ],
                  [ "Zero Page, X", "ROL $44,X",   "$76", 2, 6 ],
                  [ "Absolute",     "ROL $4400",   "$6E", 3, 6 ],
                  [ "Absolute, X",  "ROL $4400,X", "$7E", 3, 7 ],
              ],
              "description": "<p>ROR shifts all bits right one position. The\
              Carry flag is shifted into bit 7 and the original bit 0 is shifted\
              into the Carry flag."
          },

          "RTI": {
              "mnemonic": "ReTurn from Interrupt",
              "flags": [ "S", "Z", "C", "I", "V" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "RTI",         "$40", 1, 6 ],
              ],
              "description": "<p>RTI retrievs the Processor Status Word (flags)\
              and the Program Counter from the stack in that order (interrupts\
              push the PC first and then the PSW).\
              <p>\
              Not unlike RTS, the return address on the stack is the actual\
              address rather than the address-1."
          },
          "RTS": {
              "mnemonic": "ReTurn from Subroutine",
              "flags": [ "S", "Z", "C", "I", "V" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "RTS",         "$60", 1, 6 ],
              ],
              "description": "RTS pulls the top two bytes off the stack (low\
              byte first) and transfers program control to that address+1. It is\
              used, as expected, to exit a subroutine invoked via JSR, which\
              pushed the address-1.\
              <p>\
              RTS is frequently used to implement a jump table where addresses-1\
              are pushed onto the stack and accessed via RTS. E.g. to access the\
              second of four routines:\
              <pre>\n\
 LDX #1\n\
 JSR EXEC\n\
 JMP SOMEWHERE\n\
\n\
LOBYTE\n\
 .BYTE <ROUTINE0-1,<ROUTINE1-1\n\
 .BYTE <ROUTINE2-1,<ROUTINE3-1\n\
\n\
HIBYTE\n\
 .BYTE >ROUTINE0-1,>ROUTINE1-1\n\
 .BYTE >ROUTINE2-1,>ROUTINE3-1\n\
\n\
EXEC\n\
 LDA HIBYTE,X\n\
 PHA\n\
 LDA LOBYTE,X\n\
 PHA\n\
 RTS\n\
              </pre>"
          },

          "SBC": {
              "mnemonic": "SuBtract with Carry",
              "flags": [ "S", "V", "Z", "C" ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Immediate",    "SBC #$44",    "$E9", 2, 2 ],
                  [ "Zero Page",    "SBC $44",     "$E5", 2, 3 ],
                  [ "Zero Page, X", "SBC $44,X",   "$F5", 2, 4 ],
                  [ "Absolute",     "SBC $4400",   "$ED", 3, 4 ],
                  [ "Absolute, X",  "SBC $4400,X", "$FD", 3, 4, 1 ],
                  [ "Absolute, Y",  "SBC $4400,Y", "$F9", 3, 4, 1 ],
                  [ "Indirect, X",  "SBC ($44,X)", "$E1", 2, 6 ],
                  [ "Indirect, Y",  "SBC ($44),Y", "$F1", 2, 5, 1 ]
              ],
              "notes": [
                  "add 1 cycle if page boundary crossed"
              ],
              "description": "<p>SBC results are dependant on the setting of the\
              decimal flag. In decimal mode, subtraction is carried out on the\
              assumption that the values involved are packed BCD (Binary Coded\
              Decimal).\
              <p>\
              There is no way to subtract without the carry which works as an\
              inverse borrow. I.e., to subtract you set the carry before the\
              operation. If the carry is cleared by the operation, it indicates\
              a borrow occurred."
          },

          "STA": {
              "mnemonic": "STore Accumulator",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Zero Page",    "STA $44",     "$85", 2, 3 ],
                  [ "Zero Page, X", "STA $44,X",   "$95", 2, 4 ],
                  [ "Absolute",     "STA $4400",   "$8D", 3, 4 ],
                  [ "Absolute, X",  "STA $4400,X", "$9D", 3, 5 ],
                  [ "Absolute, Y",  "STA $4400,Y", "$99", 3, 5 ],
                  [ "Indirect, X",  "STA ($44,X)", "$81", 2, 6 ],
                  [ "Indirect, Y",  "STA ($44),Y", "$91", 2, 6 ]
              ]
          },

          "TSX": {
              "mnemonic": "Transfer Stack Pointer to X",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "TSX",         "$BA", 1, 2 ],
              ],
          },
          "TXS": {
              "mnemonic": "Transfer X to Stack Pointer",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "TXS",         "$9A", 1, 2 ],
              ],
          },
          "PHA": {
              "mnemonic": "PusH Accumulator",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "PHA",         "$48", 1, 3 ],
              ],
          },
          "PLA": {
              "mnemonic": "PuLl Accumulator",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "PLA",         "$68", 1, 4 ],
              ],
              "description": "The \"PuLl\" operations are known as \"POP\" on\
              most other microprocessors. With the 6502, the stack is always on\
              page one ($100-$1FF) and works top down."
          },
          "PHP": {
              "mnemonic": "PusH Processor status",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "PHP",         "$08", 1, 3 ],
              ],
          },
          "PLP": {
              "mnemonic": "PuLl Processor status",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Implied",      "PLP",         "$28", 1, 4 ],
              ],
              "description": "The \"PuLl\" operations are known as \"POP\" on\
              most other microprocessors. With the 6502, the stack is always on\
              page one ($100-$1FF) and works top down."
          },

          "STX": {
              "mnemonic": "STore X register",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Zero Page",    "STX $44",     "$86", 2, 3 ],
                  [ "Zero Page, Y", "STX $44,X",   "$96", 2, 4 ],
                  [ "Absolute",     "STX $4400",   "$8E", 3, 4 ],
              ]
          },
          "STY": {
              "mnemonic": "STore Y register",
              "flags": [ ],
              "modes": [
                  // mode            syntax         hex   l  t note
                  [ "Zero Page",    "STY $44",     "$84", 2, 3 ],
                  [ "Zero Page, Y", "STY $44,X",   "$94", 2, 4 ],
                  [ "Absolute",     "STY $4400",   "$8C", 3, 4 ],
              ]
          },
      };

      function showDescForInstruction(name) {
          var instruction = opcodes[name];
          var description = document.getElementsByTagName("description")[0];
          var innerHtml = "<closebutton onclick=\"onCloseClicked(this);\">&times;</closebutton>";
          innerHtml += "<heading>" + name + "</heading>";
          innerHtml += "<subtext>" + instruction.mnemonic + "</subtext>";

          if (instruction.operation) {
              innerHtml += "<operation>Operation: ";
              innerHtml += instruction.operation;
              innerHtml += "</operation>";
          }

          if (instruction.flags && (instruction.flags.length > 0)) {
              innerHtml += "<flags>Affects Flags: ";
              for (var flag in instruction.flags) {
                  innerHtml += instruction.flags[flag] + " ";
              }
              innerHtml += "</flags>";
          }

          innerHtml += "<table><tr><th>Mode</th><th>Syntax</th><th>Hex</th><th>Length</th><th>Time</th><th>Notes</th></tr>";
          for (var mode in instruction.modes) {
              [mode, syntax, hex, length, time, note] = instruction.modes[mode];
              innerHtml += "<tr><td>" + mode + "</td>";
              innerHtml += "<td>" + syntax + "</td>";
              innerHtml += "<td>" + hex + "</td>";
              innerHtml += "<td>" + length + "</td>";
              innerHtml += "<td>" + time + "</td>";

              innerHtml += "<td>";
              if (note) {
                  innerHtml += note;
              }
              innerHtml += "</td></tr>";
          }
          innerHtml += "</table>";

          if (instruction.notes) {
              innerHtml += "<ol>";
              for (var note in instruction.notes) {
                  innerHtml += "<li>" + instruction.notes[note] + "</li>";
              }
              innerHtml += "</ol>"
          }

          if (instruction.description) {
              innerHtml += "<text>" + instruction.description + "</text>";
          }

          description.innerHTML = innerHtml;
          description.style.display = "block";
      }

      function onClick(self) {
          showDescForInstruction(self.textContent);
      }

      function onCloseClicked(self) {
          document.getElementsByTagName("description")[0].style.display = "none";

          var loc = String(window.location);
          var hashPos = loc.indexOf("#");
          var strippedLoc = loc.substring(0, hashPos);
          window.location = strippedLoc;
      }

      function onKeyDown(event) {
          if (event.keyCode == 27) {
              onCloseClicked();
          }
      }

      var windowWidth = 0;

      function showOnAnchor() {
          if (window.location.hash) {
              var hash = window.location.hash.substr(1);

              if (hash in opcodes) {
                  showDescForInstruction(hash);
              }
          }
      }
    </script>
  </head>

  <body onkeydown="onKeyDown(event);"
        onload="onResizeEvent(); showOnAnchor();">
    <h1>6502 / 6510 / 8502 Opcode List</h1>

    <categories>
      <table>
        <th colspan="2">Register to Memory Instructions</th>
        <tr><td><a href="#LDA" onclick="onClick(this);">LDA</a></td><td><a href="#STA" onclick="onClick(this);">STA</a></td></tr>
        <tr><td><a href="#LDX" onclick="onClick(this);">LDX</a></td><td><a href="#STX" onclick="onClick(this);">STX</a></td></tr>
        <tr><td><a href="#LDY" onclick="onClick(this);">LDY</a></td><td><a href="#STY" onclick="onClick(this);">STY</a></td></tr>
      </table>

      <table>
        <th>Compare Instructions</th>
        <tr><td><a href="#CMP" onclick="onClick(this);">CMP</a></td></tr>
        <tr><td><a href="#CPX" onclick="onClick(this);">CPX</a></td></tr>
        <tr><td><a href="#CPY" onclick="onClick(this);">CPY</a></td></tr>
      </table>

      <table>
        <th colspan="2">Branching</th>
        <tr><td><a href="#BEQ" onclick="onClick(this);">BEQ</a></td><td><a href="#BNE" onclick="onClick(this);">BNE</a></td></tr>
        <tr><td><a href="#BCC" onclick="onClick(this);">BCC</a></td><td><a href="#BCS" onclick="onClick(this);">BCS</a></td></tr>
        <tr><td><a href="#BMI" onclick="onClick(this);">BMI</a></td><td><a href="#BPL" onclick="onClick(this);">BPL</a></td></tr>
        <tr><td><a href="#BVC" onclick="onClick(this);">BVC</a></td><td><a href="#BVS" onclick="onClick(this);">BVS</a></td></tr>
      </table>

      <table>
        <th colspan="2">Shift and Rotate Instructions</th>
        <tr><td><a href="#ASL" onclick="onClick(this);">ASL</a></td><td><a href="#LSR" onclick="onClick(this);">LSR</a></td></tr>
        <tr><td><a href="#ROL" onclick="onClick(this);">ROL</a></td><td><a href="#ROR" onclick="onClick(this);">ROR</a></td></tr>
      </table>

      <table>
        <th colspan="2">Jump and Return Instructions</th>
        <tr><td><a href="#JSR" onclick="onClick(this);">JSR</a></td><td><a href="#RTS" onclick="onClick(this);">RTS</a></td></tr>
        <tr><td colspan="2"><a href="#JMP" onclick="onClick(this);">JMP</a></td></tr>
        <tr><td colspan="2"><a href="#RTI" onclick="onClick(this);">RTI</a></td></tr>
      </table>

      <table>
        <th colspan="2">Counter Instructions</th>
        <tr><td><a href="#INC" onclick="onClick(this);">INC</a></td><td><a href="#DEC" onclick="onClick(this);">DEC</a></td></tr>
        <tr><td><a href="#INX" onclick="onClick(this);">INX</a></td><td><a href="#DEX" onclick="onClick(this);">DEX</a></td></tr>
        <tr><td><a href="#INY" onclick="onClick(this);">INY</a></td><td><a href="#DEY" onclick="onClick(this);">DEY</a></td></tr>
      </table>

      <table>
        <th colspan="2">Arithmetic and Logic Instructions</th>
        <tr><td><a href="#ADC" onclick="onClick(this);">ADC</a></td><td><a href="#SBC" onclick="onClick(this);">SBC</a></td></tr>
        <tr><td><a href="#BIT" onclick="onClick(this);">BIT</a></td><td><a href="#AND" onclick="onClick(this);">AND</a></td></tr>
        <tr><td><a href="#ORA" onclick="onClick(this);">ORA</a></td><td><a href="#EOR" onclick="onClick(this);">EOR</a></td></tr>
      </table>

      <table>
        <th colspan="2">Register Transfer Instructions</th>
        <tr><td><a href="#TAX" onclick="onClick(this);">TAX</a></td><td><a href="#TXA" onclick="onClick(this);">TXA</a></td></tr>
        <tr><td><a href="#TAY" onclick="onClick(this);">TAY</a></td><td><a href="#TYA" onclick="onClick(this);">TYA</a></td></tr>
        <tr><td><a href="#TSX" onclick="onClick(this);">TSX</a></td><td><a href="#TXS" onclick="onClick(this);">TXS</a></td></tr>
      </table>

      <table>
        <th colspan="2">Set and Clear Instructions</th>
        <tr><td><a href="#CLC" onclick="onClick(this);">CLC</a></td><td><a href="#SEC" onclick="onClick(this);">SEC</a></td></tr>
        <tr><td><a href="#CLD" onclick="onClick(this);">CLD</a></td><td><a href="#SED" onclick="onClick(this);">SED</a></td></tr>
        <tr><td><a href="#CLI" onclick="onClick(this);">CLI</a></td><td><a href="#SEI" onclick="onClick(this);">SEI</a></td></tr>
        <tr><td colspan="2"><a href="#CLV" onclick="onClick(this);">CLV</a></td></tr>
      </table>

      <table>
        <th colspan="2">Stack Instructions</th>
        <tr><td><a href="#PHA" onclick="onClick(this);">PHA</a></td><td><a href="#PLA" onclick="onClick(this);">PLA</a></td></tr>
        <tr><td><a href="#PHP" onclick="onClick(this);">PHP</a></td><td><a href="#PLP" onclick="onClick(this);">PLP</a></td></tr>
      </table>

      <table>
        <th colspan="2">Misc Instructions</th>
        <tr><td><a href="#NOP" onclick="onClick(this);">NOP</a></td><td><a href="#BRK" onclick="onClick(this);">BRK</a></td></tr>
      </table>
    </categories>

    <description>
      <closebutton onclick="onCloseClicked(this);">&times;</closebutton>
      <heading>LDA</heading>
      <subtext>LoaD Accumulator</subtext>
      <operation>A + operand + carry &rarr; A, C</operation>
      <flags>Affects Flags: S Z</flags>
      <table>
        <tr><th>Mode</th><th>Syntax</th><th>Hex</th><th>Length</th><th>Time</th></tr>
        <tr><td>Immediate</td><td>LDA #$44</td><td>$A9</td><td>2</td><td>2</td></tr>
        <tr><td>Zero Page</td><td>LDA $44</td><td>$A5</td><td>2</td><td>3</td></tr>
        <tr><td>Zero Page,X</td><td>LDA $44,X</td><td>$B5</td><td>2</td><td>4</td></tr>
        <tr><td>Absolute</td><td>LDA $4400</td><td>$AD</td><td>3</td><td>4</td></tr>
        <tr><td>Absolute,X</td><td>LDA $4400,X</td><td>$BD</td><td>3</td><td>4+</td></tr>
        <tr><td>Absolute,Y</td><td>LDA $4400,Y</td><td>$B9</td><td>3</td><td>4+</td></tr>
        <tr><td>Indirect,X</td><td>LDA ($44,X)</td><td>$A1</td><td>2</td><td>6</td></tr>
        <tr><td>Indirect,Y</td><td>LDA ($44),Y</td><td>$B1</td><td>2</td><td>5+</td></tr>
      </table>
      <notes>+: add 1 cycle if page boundary crossed</notes>
    </description>

    <footer>
      Data borrowed
      from <a href="http://www.6502.org/tutorials/6502opcodes.html">NMOS 6502
      Opcodes</a> by <a href="http://www.theonelab.com/">June Tate-Gans</a>
      &mdash; <a href="http://github.com/jtgans/6502ops">Code is on GitHub</a>
    </footer>
  </body>
</html>
